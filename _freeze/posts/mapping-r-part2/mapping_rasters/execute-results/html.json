{
  "hash": "6fd0eaeec4f8906c6f5fc577e0598a2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Live Session 5: Mapping in R part 2\"\nsubtitle: \"Rasters\"\nformat:\n  html:\n    toc: true\n    html-math-method: katex\n    css: styles.css\nauthor:\n  - Punam Amratia\n  - Herieth Mboya\n  - Jailos Lubinda\n  - Adam Saddler\n  - Paulina Dzianach\n  - Ellie Sherrard-Smith\n  - Justin Millar\n  - Naomi Tedto\n  \ndate: \"2025-04-17\"\ncategories: \n - R\n - Spatial data\n - Data cleaning\n - Data visualization\n - GIS\n - Live session\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n::: {.callout-note title=\"Take the survey!\"}\nIf you are present for the live session on Wednesday May 7th 2025,\nplease [click\nhere](https://docs.google.com/forms/d/e/1FAIpQLSfged5mxriKgvnJ6DiWVuHH4Fv3zeMp-iBVPnJpIEtKcDOJHg/viewform?usp=sharing)\nto take the survey.\n:::\n\n::: {#Prerequisites .callout-important}\n*Before you begin, we expect participants to have basic knowledge of R.\nIf you're new to R or would like a refresher, we recommend reviewing the\nfirst two live sessions on [data\nvisualization](https://ammnet.github.io/ammnet-hackathon/posts/data-vis/)\nand [data\nwrangling](https://ammnet.github.io/ammnet-hackathon/posts/data-wrangle/)\nbeforehand.*\n\n*Prior experience with GIS data is not required, though it may be\nhelpful. This session builds on the previous [mapping in\nR](https://ammnet.github.io/ammnet-hackathon/posts/mapping-r/) session\nthat introduced vector data (e.g. shapefiles). In this session we'll\nfocus primarily on rasters in R, with a several cool techniques to\nmanipulate rasters to help you in your malaria modelling.*\n:::\n\n::: {.callout-tip title=\"Before you start\"}\nAll of the raw materials, including the R code and data, are available\nin the [Github\nrepository](https://github.com/AMMnet/ammnet-hackathon/tree/main/04_mapping-r-part2).\n\nWe will be using the `tidyverse` , `terra`, `tidyterra` , `sf`,\n`malariaAtlas`, `RColorBrewer`, and `tmap` packages in this tutorial.\nYou may need to install them if you do not have them already. To\ninstall, run the following command in your R console:\n`install.packages(\"tidyverse\", \"terra\", \"RColorBrewer\", \"sf\", \"tidyterra\", \"malariaAtlas\")`.\nNote that the `tidyverse` package is large and may take a few minutes to\ninstall.\n\nCode from the live session is available on the\n[Github](https://github.com/AMMnet/ammnet-hackathon/tree/main/04_mapping-r-part2).\n\nData for this tutorial has been uploaded onto\n[Figshare](https://figshare.com/articles/figure/AMMnet_Hackathon_-_rasters/28839191)\nand we recommend you run the following code to download the data for\nthis tutorial\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Only run this if you don't have these packages\n#install.packages(c(\"httr\", \"fs\"))\nlibrary(httr)\nlibrary(fs)\n\n# Replace with the actual download URL\ndownload_url <- \"https://figshare.com/ndownloader/articles/28839191/versions/1\"\n#make this the destination where you want to keep the data in your local computer\noutput_file <- \"mapping-r-part2/data/rasters.zip\"\n\nGET(download_url, write_disk(output_file, overwrite = TRUE))\nunzip(\"rasters.zip\", exdir = \"data\") #exdir is the folder which you want to unzip in\n```\n:::\n\n\n:::\n\n{{< video https://www.youtube.com/embed/NP74ttyDff0?si=7zZImcQ0y8y1DGkM>}}\n\n## Overview\n\nWelcome back! We hope you enjoyed the first part of our Mapping in R\nseries, which focused on vector data. In this follow-up session, we’ll\ndive into working with **raster data** in R. We’ll begin with a brief\nintroduction to raster concepts and attributes, followed by a hands-on\nwalkthrough using real-world examples.\n\nBy the end of the session, you’ll be able to confidently load and export\nraster data, crop and reproject rasters, classify and calculate with\nraster layers, extract summary statistics, and produce publication-ready\nvisualizations in R. We’ll primarily use the `terra`, `tidyterra` and\n`tidyverse` packages to support our work.\n\n\n\n```{=tex}\n\\vspace{15pt}\n\\renewcommand\\contentsname{}\n\\setcounter{tocdepth}{2}\n\\hrule\n\\tableofcontents\n\\vspace{25pt}\n\\hrule\n```\n\n\n## Learning Objectives\n\n-   Understand the structure and characteristics of raster data\n\n-   Load, export and explore raster datasets in R\n\n-   Reproject raster data to different coordinate systems\n\n-   Plot raster data using both base and ggplot2 approaches\n\n-   Crop and mask rasters based on vector boundaries\n\n-   Aggregate or resample rasters for different resolutions\n\n-   Perform raster calculations and extract summary values\n\n-   Convert vector data to raster format (rasterizing)\n\n## **What is Raster data?**\n\nRaster data is a type of spatial data represented as a grid of cells or\npixels, where each cell has a specific value representing information\nabout the area it covers. It's commonly used in Geographic Information\nSystems (GIS) and remote sensing to represent continuous phenomena such\nas:\n\n-   Elevation (Digital Elevation Models - DEMs)\n\n-   Temperature\n\n-   Rainfall\n\n-   Land cover\n\n-   Other Satellite imagery\n\n**Characteristics of Raster Data**: Raster data is made up of rows and\ncolumns forming a matrix or grid.\n\n**Cell or Pixel Value**: Each cell in the grid has a value representing\na certain attribute (e.g., temperature, vegetation index).\n\n**Spatial Resolution**: The size of each cell determines the resolution\n– smaller cells provide more detail (higher resolution), while larger\ncells provide less detail (lower resolution).\n\n**Coordinate System**: Raster data is often georeferenced, meaning it is\ntied to specific locations on the Earth's surface using a coordinate\nsystem (e.g., latitude/longitude, UTM).\n\n**File Formats**: Common formats include GeoTIFF, NetCDF, ASCII Grid,\nand IMG.\n\n+------------------------+------------------------+\n| Advantages             | Diadvantages           |\n+========================+========================+\n| -   Good for           | -   Can require large  |\n|     representing       |     storage space,     |\n|     continuous data    |     especially at high |\n|     (e.g., elevation,  |     resolution.        |\n|     pollution levels). |                        |\n+------------------------+------------------------+\n| -   Easier to          | -   May lose detail    |\n|     manipulate and     |     when resampled or  |\n|     analyze with       |     re-projected.      |\n|     mathematical       |                        |\n|     functions (e.g.,   |                        |\n|     averaging,         |                        |\n|     summing).          |                        |\n+------------------------+------------------------+\n| -   Compatible with    | -   Less suitable for  |\n|     remote sensing     |     representing       |\n|     data which is      |     discrete objects   |\n|     inherently         |     (e.g., buildings,  |\n|     raster-based.      |     roads).            |\n+------------------------+------------------------+\n|                        |                        |\n+------------------------+------------------------+\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](figs/raster_concept.png){width=100%}\n:::\n:::\n\n\n\n### **Raster data in R using `terra`**\n\nThere are two major packages available to handle rasters in R: `terra`\nand `raster`. The `terra` package is the newer, faster, and more\nefficient alternative to the older `raster` package in R for handling\nraster data. Both packages are commonly used for spatial data analysis,\nbut there are some important differences. Namely, it is optimized for\nperformance, particularly when working with large raster datasets. New\nfeatures are regularly added, with better compatibility with the `sf`\npackage and finally functions are cleaner, more consistent, and easier\nto remember.\n\nfor this tutorial we'll be using the `terra` package to read,\nmanipulate, and writing raster data.\n\n### **SpatRaster**\n\nA `SpatRaster` represents multi-layer (multi-variable) raster data. A\nSpatRaster always stores a number of fundamental parameters decribing\nits geometry. These include the number of columns and rows, the spatial\nextent, and the Coordinate Reference System. In addition, a `SpatRaster`\ncan store information about the file in which the raster cell values are\nstored. Or, if there is no such a file, a `SpatRaster` can hold the cell\nvalues in memory.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](figs/SpatRaster.png){width=100%}\n:::\n:::\n\n\n\nwe'll start off by loading in some key packages we'll be using during\nthis tutorial section\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(tidyverse)\nlibrary(malariaAtlas)\nlibrary(RColorBrewer)\n```\n:::\n\n\n\n## Loading raster data\n\nFor this tutorial we're going to stick to using Tanzania as an example.\nIn your drive you'll find in the `data/rasters/` folder where we have\nsome pre-downloaded population rasters from\n[WorldPop](https://www.worldpop.org/datacatalog/).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lets load a population raster in R\npopulation <- rast(\"data/rasters/tza_pop_2022_constrained.tif\")\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 12916, 13342, 1  (nrow, ncol, nlyr)\nresolution  : 0.0008333333, 0.0008333333  (x, y)\nextent      : 29.32708, 40.44542, -11.74542, -0.9820831  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : tza_pop_2022_constrained.tif \nname        : tza_ppp_2020_constrained \nmin value   :                    0.000 \nmax value   :                 2387.388 \n```\n\n\n:::\n:::\n\n\n\nWhen you load the raster you'll see some metadata that highlights the\nspatial extent (i.e. the bounding box around the raster); the coordinate\nreference system and the resolution (i.e. size of the pixel). This\nraster is what you call a single layer raster.\n\nNote that `population` is a SpatRaster of with a single band. The nice\nthing about `terra` package is you can also deal with multiple rasters,\ncreating mutliple bands or already multi-band satellite imageries.\nlayers (“bands”). It also work with other raster file formats, including\nGeoTiff, NetCDF, Imagine, and ESRI Grid formats.\n\ntypically at this stage you can use the `terra::plot()` function to\nsimply plot the population raster you have loaded\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(population)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/plot1-1.png){width=672}\n:::\n:::\n\n\n\nThis is a nice quick way to look at the image you've brought in. Besides\nloading rasters into R from a download. There are some rasters that are\navailable in packages that could be of interest to malaria modelers.\nWe'll download a *Plasmodium falciparum* parasite rate surface from the\n`malariaAtlas` package as an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#first we'll load the tanzania shapefile from the package\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStart tag expected, '<' not found\nStart tag expected, '<' not found\n```\n\n\n:::\n\n```{.r .cell-code}\n#next we'll load the dataset of PfPR for the year 2022\npfpr_2022 <- getRaster(dataset_id = \"Malaria__202406_Global_Pf_Parasite_Rate\", year = 2022, shp = tz_districts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<GMLEnvelope>\n....|-- lowerCorner: -11.7612 29.3414 \"2000-01-01T00:00:00\"\n....|-- upperCorner: -0.9844 40.4432 \"2022-01-01T00:00:00\"Start tag expected, '<' not found\n```\n\n\n:::\n:::\n\n\n\nHere is another way to download rasters. We can also quickly plot this\ndata using the `malariaAtlas` package or using `terra`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(pfpr_2022)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/plot pfpr-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(pfpr_2022, main = \"PfPR 2-10 in 2022\")\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/plot pfpr-2.png){width=672}\n:::\n:::\n\n\n\ncoming back to the actual raster you'll notice that the there are two\nlayers in the data. This is known as a multiband rasters. this second\nlayer in the prevalence surface is a population mask which seems to be\nempty so we can also just drop this band and treat it like a single band\nraster.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npfpr_2022\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 258, 266, 2  (nrow, ncol, nlyr)\nresolution  : 0.04166667, 0.04166667  (x, y)\nextent      : 29.33333, 40.41667, -11.75, -0.9999987  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : Malaria__202406_Global_Pf_Parasite_Rate_2022-01-01T00_00_00_-11.7612,29.3414,-0.9844,40.4432 \nnames       : Proportion of C~ 2000-2022-2022, Mask: Sparsely Populated \nmin values  :                       0.0000000,                      NaN \nmax values  :                       0.3834594,                      NaN \n```\n\n\n:::\n\n```{.r .cell-code}\npfpr_2022 <- pfpr_2022[[1]]\n\n#the name of the raster is super long, so we'll fix that\nnames(pfpr_2022) <- \"pfpr_2022\"\n```\n:::\n\n\n\n## Projecting/Reprojecting\n\nRaster data, like vector data, has a coordinate reference system (CRS).\nSometimes we need to reproject a raster to match the CRS of other\nspatial layers.\n\nHowever, unlike vectors, raster data is made up of a fixed grid of\ncells. When projecting, this grid must be resampled, meaning new cell\nvalues are estimated based on the original ones. This can alter the\ndata, so it's best to avoid reprojecting rasters unless necessary.\nCommon resampling methods including “nearest neighbor” for categorical\ndata (e.g., land cover) and \"bilinear\" for continuous data (e.g.,\nelevation, temperature).\n\nBecause projection of rasters affects the cell values, in most cases you\nwill want to avoid projecting raster data and rather project vector data\nwhich will have no distortion effect. But here is how you can project\nraster data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- rast(xmin=-110, xmax=-90, ymin=40, ymax=60, ncols=40, nrows=40)\nvalues(r) <- 1:ncell(r)\nr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 40, 40, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -110, -90, 40, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        : lyr.1 \nmin value   :     1 \nmax value   :  1600 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(r)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/project-alternative-1.png){width=672}\n:::\n\n```{.r .cell-code}\nnewcrs <- \"+proj=robin +datum=WGS84\"\npr1 <- terra::project(r, newcrs)\ncrs(pr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PROJCRS[\\\"unknown\\\",\\n    BASEGEOGCRS[\\\"unknown\\\",\\n        DATUM[\\\"World Geodetic System 1984\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ID[\\\"EPSG\\\",6326]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8901]]],\\n    CONVERSION[\\\"unknown\\\",\\n        METHOD[\\\"Robinson\\\"],\\n        PARAMETER[\\\"Longitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"False easting\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(pr1)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/project-alternative-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define target CRS\n#we're going to use the Universal Mercator Projection (which makes the world flat)\ntarget_crs <- \"EPSG:3857\"\n\n# Reproject raster\nprojected_population <- project(population, target_crs, method = \"bilinear\") #bilinear because we assume population is continuous\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(projected_population)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/project-1.png){width=672}\n:::\n:::\n\n\n\n## Plotting Raster Data\n\nso far we've seen we can plot raster data using the basic `terra`\nfunctions of `plot()`. But perhaps you might want to change things about\nhow the raster looks (e.g. colors) or bin the information, we might want\nto plot the data in `ggplot()` instead. We're going to do this with our\nparasite prevalence surface\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_raster(data = pfpr_2022, mapping = aes(x=x, y =y, fill = pfpr_2022))+\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/ggplot-1.png){width=672}\n:::\n:::\n\n\n\n`geom_raster()` or `geom_tile()` are the two main functions you can use\nggplot to plot raster/gridded data. Typically in both you would need to\ngive it the x,y (coordinates) and the value to fill in the cell for it\nto plot correctly. You would also need to include the extra layer on how\nto deal with coordinates called `coord_equal()`. When you are adding in\nsf shapefiles you might switch to `coord_sf()` for it to know how to\ntreat the coordinates appropriately. Try and see what the image looks\nlike when you leave it out.\n\nAlternatively, `geom_spatraster()` comes from the package `tidyterra`\nand is the fastest and easiest way to make a plot of a raster in ggplot,\nwe'll mostly use `geom_spatraster` from here onwards as then we won't\nneed to include additional information on x,y and the coordinates\ninformation. From the above plot you can see the default is not\nparticularly pretty, so let's make this look prettier\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(tz_districts)+\n  geom_sf()+\n  geom_spatraster(data = pfpr_2022, mapping = aes(fill = pfpr_2022))+\n  geom_sf(fill = NA)+\n  scale_fill_distiller(palette = \"RdYlGn\", na.value = 'transparent')+\n  theme_void()+\n  labs(title = \"Plasmodium falciparum 2-10 for 2022\", fill = \"PfPR\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Computation failed in `stat_terra_spat_raster()`.\nCaused by error:\n! [spatSample] at least one of 'values', 'cells', or 'xy' must be TRUE; or 'as.points' must be TRUE\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/ggplot1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define color palette (5 bins = 5 colors)\npfpr_pal <- brewer.pal(n = 5, name = \"RdYlGn\")\npfpr_pal <- rev(pfpr_pal) #reverse it to make low green and high red\n\n# Define break points\npfpr_breaks <- c(0, 0.05, 0.1, 0.2, 0.3, 1)\n\nggplot() +\n  geom_spatraster(data = pfpr_2022, aes(fill = pfpr_2022)) +\n  geom_sf(data = tz_districts, fill = NA) +\n  scale_fill_stepsn(colours = pfpr_pal, breaks = pfpr_breaks, na.value = 0) +\n  theme_void() +\n  labs(title = \"Plasmodium falciparum 2-10 for 2022\", fill = \"PfPR\")\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/ggplot2-1.png){width=672}\n:::\n:::\n\n\n\n::: {#challenge1 .callout-tip}\n## Challenge 1: Make a plot of the population\n\n-   Try make the same map as above but using the `population` raster\n    instead\n-   What color palette would help make this more representative?\n-   Can you perhaps change the scale of the values to log10?\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(tz_districts)+\n  geom_sf()+\n  geom_spatraster(data = population, mapping = aes(fill = tza_ppp_2020_constrained))+\n  geom_sf(fill = NA)+\n  scale_fill_viridis_c(option = \"D\", na.value = \"transparent\", trans = \"log10\", direction = -1)+\n  theme_void()+\n  labs(title = \"Population count for 2022\", fill = \"All age\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<SpatRaster> resampled to 500424 cells.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Computation failed in `stat_terra_spat_raster()`.\nCaused by error:\n! [spatSample] at least one of 'values', 'cells', or 'xy' must be TRUE; or 'as.points' must be TRUE\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/sol1-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Manipulating rasters\n\nWe can find out the spatial extent of a raster by using the `ext()`\nfunction, and easily crop the raster to other extents using `crop()`. We\ncan specify the coordinates we wish to crop the raster to, or a take the\nextent from a spatial object and crop the raster to that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\next(pfpr_2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatExtent : 29.3333333333333, 40.4166666666666, -11.7499987284343, -0.999998728434268 (xmin, xmax, ymin, ymax)\n```\n\n\n:::\n\n```{.r .cell-code}\npfpr1 <- crop(pfpr_2022, c(-8,35,-6,25))   # c(xmin, xmax, ymin, ymax)\nplot(pfpr1)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/crop-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# crop malaria prevalence to just kilimanjaro\nmtwara <- filter(tz_districts, name_1 == 'Mtwara')\nmtwara_pfpr <- crop(pfpr_2022, mtwara)\nplot(mtwara_pfpr)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/crop-2.png){width=672}\n:::\n:::\n\n\n\nWe may then want to change all of the raster cells which lay outside of\nthe polygon for Mtwara region to be NA. This can be done using `mask()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mask malaria prevalence to just kilimanjaro\nmtwara <- filter(tz_districts, name_1 == 'Mtwara')\nmtwara_pfpr <- crop(pfpr_2022, mtwara) %>% mask(mtwara) #reccomend to crop to set new extents\nplot(mtwara_pfpr)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nwhen masking you'd want to consider that mask does not help with setting\nextents so its best to first `crop` and then `mask`\n\n## Aggregating/Resampling\n\nAs you noticed in the population raster you have a very high resolution\non 100m, when visualising it can be challenging so we may want to\naggregate the rasters up.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_1km <- aggregate(population, fact = 10, fun = \"sum\", na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(population_1km)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/aggregate-1.png){width=672}\n:::\n:::\n\n\n\nYou can disaggregate using the function `disagg` but you would need to\nbe careful as you would need to use the methods \"near\" or \"bilinear\" to\ninterpolate into smaller cells. This could distort the information in\nthe raster unknowningly.\n\n## Raster maths\n\nwith multiple rasters you can also do some simple calculations. One that\nmight be useful is if you wanted to calculated the population at risk of\nmalaria. A few things to remember is that the rasters must be of the\nsame extent. We can use the `resample` function to align them\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#check extent matches\next(population_1km) == ext(pfpr_2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#if they don't match use resample to get them to match\npopulation_1km_resamp <- resample(population_1km, pfpr_2022)\n\n#Now we can multiply the population and prevalence information to get population at risk\npop_at_risk <- population_1km_resamp * pfpr_2022\nnames(pop_at_risk) = \"population_at_risk\"\n\nggplot()+\n  geom_raster(pop_at_risk, mapping = aes(x = x, y = y, fill = population_at_risk))+\n  geom_sf(tz_districts, mapping = aes(geometry = geometry), fill=NA)+\n  scale_fill_viridis_c(option = \"B\", trans = \"log10\", na.value = \"transparent\")+\n  theme_void()+\n  coord_sf()+\n  labs(title = \"Population at risk in 2022\", fill = \"Population\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in scale_fill_viridis_c(option = \"B\", trans = \"log10\", na.value =\n\"transparent\"): log-10 transformation introduced infinite values.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/pop_risk-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Challenge 2: Modifying prevalence into a percentage\n\n-   Can you try to manipulate the `pfpr_2022` raster to be in percentage\n    form?\n-   Make a plot of the new percentage form `pfpr_2022` raster\n-   Can you try to categorise it.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define color palette (5 bins = 5 colors)\npfpr_pal <- brewer.pal(n = 5, name = \"RdYlGn\")\npfpr_pal <- rev(pfpr_pal) #reverse it to make low green and high red\n\n# Define break points\npfpr_breaks <- c(0, 5, 10, 20, 30,100)\n\nggplot(tz_districts)+\n  geom_sf()+\n  geom_spatraster(data = pfpr_2022*100, mapping = aes(fill = pfpr_2022))+\n  geom_sf(fill = NA)+\n  scale_fill_stepsn(colours = pfpr_pal, breaks = pfpr_breaks, na.value = 0) +\n  theme_void()+\n  labs(title = \"Plasmodium falciparum 2-10 for 2022\", fill = \"PfPR\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Computation failed in `stat_terra_spat_raster()`.\nCaused by error:\n! [spatSample] at least one of 'values', 'cells', or 'xy' must be TRUE; or 'as.points' must be TRUE\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/sol2-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Extracting information\n\nWe might want to summarise the rasters to the district level. We can do\nthat using the `extract` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_risk <- terra::extract(pop_at_risk, vect(tz_districts), sum, na.rm=TRUE, ID = FALSE)\n\ntz_districts <- bind_cols(tz_districts, pop_risk)\n\nggplot(tz_districts)+\n  geom_sf(mapping = aes(fill = population_at_risk))+\n  scale_fill_distiller(palette = \"Reds\", direction = 1, trans = 'log10', na.value = \"lightblue\")+\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/extract-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Challenge 3: Extracting more information\n\n-   Can you extract the `pfpr_2022` only values and the population\n    separately?\n-   Do you get a different value if you use `population` at 100m vs\n    `population_1km` at 1km?\n-   Can you explain why?\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npfpr <- terra::extract(pfpr_2022, vect(tz_districts), mean, na.rm=TRUE, ID = FALSE)\npop <- terra::extract(population_1km_resamp, vect(tz_districts), sum, na.rm=TRUE, ID = FALSE)\n\ntz_districts <- bind_cols(tz_districts, pfpr, pop)\n\nggplot(tz_districts)+\n  geom_sf(mapping = aes(fill = pfpr_2022))+\n  scale_fill_distiller(palette = \"RdYlGn\", na.value = \"lightblue\")+\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/sol3-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Mutliband data\n\ni've mentioned previously that terra in R has the ability to deal with\nmultiple bands/layers of rasters. So we can load several rasters all in\nat the same time and perform calculations on them in the same way which\nis great! the rasters do need to be of the same spatial extent and\nprojection for them to be loaded in correctly. Here we're going to load\nin data pulled from [CHIRPS](https://www.chc.ucsb.edu/data/chirps) about\nmonthly rainfall in 2022.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#first we create a list of all the rasters for chirps\nrainfall_rasters <- list.files(path = \"data/rasters/\", pattern = \"chirps\", full.names = TRUE)\n\n#then we'll load it into R the same way we do a single band\nrainfall_2022 <- rast(rainfall_rasters)\nrainfall_2022\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 258, 267, 12  (nrow, ncol, nlyr)\nresolution  : 0.04166667, 0.04166667  (x, y)\nextent      : 29.33333, 40.45833, -11.75, -1  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsources     : chirps-v2-0.2022.01.sum.5km.NN.tif  \n              chirps-v2-0.2022.02.sum.5km.NN.tif  \n              chirps-v2-0.2022.03.sum.5km.NN.tif  \n              ... and 9 more sources\nnames       : chirp~km.NN, chirp~km.NN, chirp~km.NN, chirp~km.NN,  chirp~km.NN,  chirp~km.NN, ... \nmin values  :    20.05125,    10.48068,    9.421162,    4.000703,   0.04140074, 2.701764e-10, ... \nmax values  :   944.62292,   671.34375,  610.169739,  804.803101, 403.89791870, 2.246316e+02, ... \n```\n\n\n:::\n:::\n\n\n\nyou'll find the meta data shows you have 12 nlyrs (layers) that have\nbeen loaded in and each layer is a month of rainfall. We can plot this\nto see what it looks like\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(rainfall_2022)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/plot multi-1.png){width=672}\n:::\n:::\n\n\n\nThe nice thing is it plots all 12 at the same time, but uses free\nscales. We can also use `ggplot` to do the same\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#let's maybe first clean up the names, turn them into dates\nnames(rainfall_2022) <- seq(ym(\"2022-01\"), ym(\"2022-12\"), by = \"months\") %>% format(\"%b %Y\")\n\nggplot()+\n  geom_spatraster(data = rainfall_2022)+\nfacet_wrap(~lyr, ncol = 4)+\n  scale_fill_distiller(palette = \"Blues\", direction = 1, na.value = \"transparent\", trans = 'sqrt')+\n  theme_void()+\n  labs(fill = \"mm\", title = \"Rainfall\")\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/ggplot multi-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Challenge 4: Handling rainfall\n\n-   Can you extract the sum of rainfall in every district in Tanzania\n    for each month?\n-   Make a plot of the rainfall patterns in regions by month\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrainfall <- terra::extract(rainfall_2022, tz_districts, sum, na.rm=TRUE, ID = FALSE)\n\ntz_rainfall <- tz_districts %>% \n  bind_cols(rainfall)\n\ntz_rainfall %>% \n  pivot_longer(cols = `Jan 2022`:`Dec 2022`, names_to = \"date\", values_to =\"rain\") %>% \nggplot()+\n  geom_sf(mapping = aes(fill = rain/1000))+\n  facet_wrap(~date)+\n  scale_fill_distiller(palette = \"Blues\", direction = 1, na.value = \"transparent\", trans = 'sqrt')+\n  theme_void()+\n  labs(fill = \"m\", title = \"Rainfall\")\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/sol4-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Rasterizing\n\nYou might want to sometimes convert vector data into raster. This\nprocess is called rasterizing. For this function to work you need a\ntemplate raster you want to use to provide it the resolution, crs and\nextents.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrasterise_pop_risk <- rasterize(tz_districts, field = \"population_at_risk\", pop_at_risk)\nplot(rasterise_pop_risk)\n```\n\n::: {.cell-output-display}\n![](mapping_rasters_files/figure-html/rasterize-1.png){width=672}\n:::\n:::\n\n\n\n## Exporting raster data\n\nUse `writeRaster` to write raster data. You must provide a SpatRaster\nand a filename. The file format will be guessed from the filename\nextension. If that does not work you can provide an argument like\n`format=GTiff`. Note the argument `overwrite=TRUE` and see\n`?writeRaster` for more arguments, such as `datatype=` to set the a\nspecific datatype (e.g., integer).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(pop_at_risk, \"data/rasters/population_risk_2022.tif\")\n```\n:::\n\n\n\n## Sources for Raster data for modelling\n\nIn this tutorial I've only shown you two sources of information from\n[WorldPop](https://www.worldpop.org/) and\n[MAP](https://data.malariaatlas.org/trends?year=2022&metricGroup=Malaria&geographicLevel=admin0&metricSubcategory=Pf&metricType=rate&metricName=incidence)\nbut there can be mainly other useful sources to get others types of\nrasters like environmental covariates\n\n[WorldClim](https://www.worldclim.org/) a great resource for bio\nclimatic raster pre-made. They include historical (1970 - 2000) and\nfuture (upto 2100) and are processed for Global climate models with some\nof the SSPs scenarios. The data also comes at different resolutions\ndepending on your analysis.\n\n[GoogleEarthEngine](https://developers.google.com/earth-engine/datasets/catalog):\ngot alot of pre-processes raster data like MODIS NASA (temperature, EVI,\nlandcover) as well as some of the MAP products. It includes some really\nnice ones too like Google Build footprints\n\n[VectorAtlas](https://vectoratlas.icipe.org/): a great place to find\nsome pulled together vector information and some of the published vector\nmaps. They are coming out with some new suitability maps very soon so a\ngreat place to view for all the mathematical modelers looking for vector\ninformation.\n\n[IHME burden\nestimates](https://ghdx.healthdata.org/local-and-small-area-estimation):\nsome rasters for different diseases and mortality get published here and\nmight be a good resource outside of malaria but also for mortality\ntrends\n\n## Additional Resources\n\n[Carpentries Introduction to Geospatial Raster and Vector data in\nR](https://datacarpentry.github.io/r-raster-vector-geospatial/01-raster-structure.html)\nis a great tutorial that inspired much of the material in this\nhackathon. Try it out!\n\n[MAP\nTraining](https://malaria-atlas-project.gitlab.io/intro-to-spatial-analysis-for-infectious-diseases/04_spatial_in_R.html#Raster_data)\nis the foundational material used to develop these notes and has much\nmore information beyond just rasters\n\n[The terra package](https://rspatial.org/pkg/1-introduction.html)\nhighlights even more cooler things you can do with rasters in R beyond\nwhat we can cover here so worth checking out for the enthusiasts!\n\n::: callout-tip\n## Extra data challenge! Tidytuesday\n\nFor the entusiasts whom might want to try making cooler rasters here is\na tidytuesday challenge. to map out [Global Holidays and\nTravel](https://github.com/rfordatascience/tidytuesday/blob/main/data/2024/2024-12-24/readme.md)\ncourtesy of WorldPop\n\nFor more fun challenges and getting practise in general in R i highly\nreccomend trying out\n[tidytuesday](https://github.com/rfordatascience/tidytuesday)\n:::\n",
    "supporting": [
      "mapping_rasters_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}