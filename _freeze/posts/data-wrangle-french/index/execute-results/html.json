{
  "hash": "5ce9cd4df0b067e0e3fc8d508e75598a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Live Session 4: Introduction à la manipulation de données dans R\"\nformat: html\nauthor: \n  - Lazaro Mwandigha  \n  - Christian Selinger\n  - Ellie Sherrard-Smith\n  - Justin Millar\ndate: \"2025-04-09\"\ncategories: \n - R\n - Data cleaning\n - Data validation\n - Français\n - Live session\n---\n\n\n\n::: {.callout-note title=\"Take the survey!\"}\n\nSi vous êtes présent à la session en direct le lundi 21 octobre, veuillez [cliquer ici](https://docs.google.com/forms/d/e/1FAIpQLSeZU0mYYkKJbJKnTr0EfO_CA4nZJhUYRdbxZcqds3vnU82w1g/viewform?usp=sharing) pour participer à l'enquête.\n:::\n\n::: {.callout-tip title=\"Before you start\"}\nTout le matériel nécessaire, y compris le [code R](https://github.com/AMMnet/ammnet-hackathon/tree/main/02_data-wrangle/R) et les [données](https://github.com/AMMnet/ammnet-hackathon/tree/main/02_data-wrangle/data), sont disponibles dans le [répertoire Github](https://github.com/AMMnet/ammnet-hackathon/tree/main/02_data-wrangle).\n\nNous utiliserons les packages `tidyverse` and `validate` dans ce tutoriel. Vous devrez peut-être les installer si vous ne les avez pas déjà. Pour les installer, exécutez la commande suivante dans votre console R : `install.packages(\"tidyverse\", \"validate\")`. Notez que le package `tidyverse` est volumineux et peut prendre quelques minutes pour s'installer.\n\nLe code de la session en direct est disponible [sur  Github](https://github.com/AMMnet/ammnet-hackathon/tree/main/02_data-wrangle/R/live-session-code.R).\n:::\n\n## Introduction\n\n### Qu'entendons-nous par \"data wrangling\" (traitement des données)?\n\nLe dictionnaire de Cambridge donne plusieurs significations au verbe [wrangle](https://dictionary.cambridge.org/dictionary/english/wrangle):\n\n1. to argue with someone about something, especially for a long time (se disputer avec quelqu'un à propos de quelque chose, en particulier pendant une longue période)\n\n2. to take care of, control, or move animals, especially large animals such as cows or horses (*mainly American English*) (prendre soin, contrôler ou déplacer des animaux, en particulier les gros animaux comme les vaches ou les chevaux)\n\n3. to move a person or thing somewhere, usually with difficulty or using force (déplacer une personne ou une chose quelque part, généralement avec difficulté ou en utilisant la force)\n\n4. to take care of or **deal with something, usually when this is difficult** (prendre soin de ou **gérer quelque chose, généralement lorsque cela est difficile**)\n\n\n### Data Wrangling (traitement des données)\n\nPar \"traitement des données\", nous entendons ici le processus de vérification et de correction de la qualité et de l’intégrité des données pertinentes pour la modélisation du paludisme, avant toute analyse ultérieure. Ce processus est également connu sous le nom de validation des données.\n\nLa **validation de données** consiste à vérifier divers aspects de votre ensemble de données, tels que les valeurs manquantes, les types de données, les valeurs aberrantes et le respect de règles ou de contraintes spécifiques. \n\nValider nos données contribue à maintenir leur **qualité et leur intégrité**, garantissant que toutes les analyses ou décisions prises sur la base des données sont robustes et fiables.\n\n\n### Pourquoi valider les données?\n\n**Garantir l'intégrité des données** : la validation des données permet d'identifier et de corriger les erreurs, garantissant ainsi l'intégrité de l'ensemble de données.\n\n**Améliorer l'exactitude des analyses** : des données propres et validées permettent d'obtenir des résultats d'analyse et de modélisation plus précis.\n\n**Conformité et normes** : la validation des données garantit que les données sont conformes aux règles, normes ou exigences réglementaires prédéfinies.\n\n**Prévention des erreurs** : la détection précoce des erreurs permet d'éviter les problèmes en aval et de faire gagner du temps lors de leur résolution.\n\n\n## Getting Started\n\nBefore you begin, you might want to create a new project in RStudio. This can be done by clicking on the \"New Project\" button in the upper right corner of the RStudio window. You can then name the project and choose a directory to save it in.\n\nNext, we will load the `tidyverse` package. This package provides a set of useful functions for data manipulation and visualization. We will use the `ggplot2` package to create plots in the later section of this tutorial.\n\nAvant de commencer, il est recommendé de créer un nouveau projet dans RStudio. Pour cela, cliquez sur le bouton \"Nouveau projet\" dans le coin supérieur droit de la fenêtre RStudio. Vous pouvez ensuite nommer le projet et choisir un répertoire dans lequel l'enregistrer.\n\nEnsuite, nous allons charger le package `tidyverse`. Ce package fournit un ensemble de fonctions utiles pour la manipulation et la visualisation des données. Nous utiliserons le package `ggplot2` pour créer des graphiques dans la dernière section de ce tutoriel.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(tidyverse)\n```\n:::\n\n\n\nEnsuite, nous allons télécharger les deux exemples de jeux de données que nous utiliserons dans ce tutoriel. Ceux-ci sont disponibles dans le [répertoire GitHub AMMnet Hackathon](https://github.com/AMMnet/AMMnet-Hackathon). \n\nJe suggère de créer un dossier `data` dans votre projet R, puis nous pourrons télécharger les deux exemples d'ensembles de données afin qu'ils soient enregistrés sur votre ordinateur.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data folder\ndir.create(\"data\")\n\n# Download example data\nurl <- \"https://raw.githubusercontent.com/AMMnet/AMMnet-Hackathon/main/02_data-wrangle/data/\"\n\ndownload.file(paste0(url, \"mockdata_cases1.csv\"), destfile = \"data/mockdata_cases1.csv\")\ndownload.file(paste0(url, \"mosq_mock1.csv\"), destfile = \"data/mosq_mock1.csv\")\n\n# Load example data\ndata_cases   <- read_csv(\"data/mockdata_cases1.csv\")\nmosq_data  <- read_csv(\"data/mosq_mock1.csv\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nLes deux ensembles de données que nous utiliserons sont `mockdata_cases1.csv` et `mosq_mock1.csv`, qui sont des exemples d'ensembles de données fictifs qui devraient être similaires aux données de surveillance des cas de paludisme et de collecte de moustiques sur le terrain, respectivement. Dans les sections suivantes, nous utiliserons `mockdata_cases1.csv` et `mosq_mock1.csv` pour introduire les concepts de nettoyage et de caractérisation des données dans R.\n\n## 1.  Vérifier les données pour détecter d'éventuelles erreurs\n\n### La prévalence est une fraction définie dans [0,1]\n\n**Note:** Une prévalence de 0 ou 1, bien que non statistiquement erronée, doit être vérifiée pour en garantir l'exactitude.\n\nQuelles observations comportent des erreurs ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Erroneous values for prevalence\ndata_cases%>%\n   dplyr::filter(prev <= 0 | prev >= 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 10\n  location month  year ages  total positive xcoord ycoord    prev time_order_loc\n  <chr>    <dbl> <dbl> <chr> <dbl>    <dbl>  <dbl>  <dbl>   <dbl>          <dbl>\n1 mordor       4  2018 15_a…    91       23  -20.0   30.5 25.3                 4\n2 neverwh…     2  2019 15_a…    22       -1  -20.8   29.6 -0.0455             14\n3 neverwh…     3  2018 unde…    25        0  -19.8   30.2  0                   3\n```\n\n\n:::\n:::\n\n\n**Commentaire:** Nous avons deux observations avec des valeurs non-logiques de `prev` : `25.3`and `-0.455`, et une ligne avec `prev` égale zéro pour un certain mois. \n\n\n### Programmation défensive\n\n**Remarque:** L'utilisation de \"::\" nous permet d'appeler une fonction à partir d'un package spécifique de `R`. Il arrive que si le package de base \"stats\" est appelé en premier, la fonction de filter, si elle n'est pas spécifiée avec le package `R`, échoue.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Erroneous values for prevalence\ndata_cases%>%\n    stats::filter(prev < 0 | prev > 1) \n```\n:::\n\n\n\n### Nous corrigeons les deux prévalences en recalculant \n\nUne bonne pratique est de laisser les données d'origine intactes (avantage de R sur Stata):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Update erroneous values for prevalence\ndata_prev <- data_cases%>%\n                       dplyr::mutate(prev_updated=positive/total)\n```\n:::\n\n\n\nNous avons une observation avec une valeur négative par erreur.\n\nQuelles sont vos options?\n\n1. Ne jamais supprimer les données\n\n2. Interroger et demander à l'équipe de gestion des données de procéder aux investigations nécessaires et de procéder à une correction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_prev%>%\n    dplyr::filter(prev_updated <= 0 | prev_updated >= 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 11\n  location month  year ages  total positive xcoord ycoord    prev time_order_loc\n  <chr>    <dbl> <dbl> <chr> <dbl>    <dbl>  <dbl>  <dbl>   <dbl>          <dbl>\n1 neverwh…     2  2019 15_a…    22       -1  -20.8   29.6 -0.0455             14\n2 neverwh…     3  2018 unde…    25        0  -19.8   30.2  0                   3\n# ℹ 1 more variable: prev_updated <dbl>\n```\n\n\n:::\n:::\n\n\n\nPour l'instant (afin de poursuivre cette démonstration), nous abandonnons les observations problématiques.\n\nPourquoi cela ne fonctionne-t-il pas ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter erroneous values for prevalence, wrong way\ndata_use <- data_prev%>%\n              dplyr::filter (prev_updated >= 0 | prev_updated <= 1)\n```\n:::\n\n\n\nPourquoi cela ne fonctionne-t-il pas ?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter erroneous values for prevalence\ndata_use <- data_prev%>%\n             dplyr::filter (prev_updated >= 0 )%>%\n              dplyr::filter (prev_updated <= 1)\n\ndata_use%>%\n       dplyr::filter(prev_updated <= 0 | prev_updated >= 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 11\n  location   month  year ages  total positive xcoord ycoord  prev time_order_loc\n  <chr>      <dbl> <dbl> <chr> <dbl>    <dbl>  <dbl>  <dbl> <dbl>          <dbl>\n1 neverwhere     3  2018 unde…    25        0  -19.8   30.2     0              3\n# ℹ 1 more variable: prev_updated <dbl>\n```\n\n\n:::\n:::\n\n\n\n### Schemas\n\nPour éviter que des erreurs n'apparaissent dans vos données, vous devez définir un **schéma** qui accompagne vos données enregistrées. Un schéma est un document qui énonce les règles relatives aux types de données et aux valeurs ou plages attendues dans une colonne particulière de votre bloc de données.\n\nPar exemple, pour la prévalence, nous savons qu'il doit s'agir d'un nombre réel compris entre zéro et un.\n\nLe package R `validate` peut être utilisé pour créer un schéma pour votre trame de données:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter erroneous values for prevalence\nlibrary(validate)\nschema <- validate::validator(prev >= 0,\n                   prev <= 1,\n                   positive >= 0)\n\nout   <- validate::confront(data_cases, schema)\nsummary(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  name items passes fails nNA error warning             expression\n1   V1   514    513     1   0 FALSE   FALSE     prev - 0 >= -1e-08\n2   V2   514    513     1   0 FALSE   FALSE      prev - 1 <= 1e-08\n3   V3   514    513     1   0 FALSE   FALSE positive - 0 >= -1e-08\n```\n\n\n:::\n:::\n\n\nEn utilisant le schéma des colonnes `prev` et `positive`, nous aurions pu facilement détecter les trois entrées problématiques. Pour plus de détails, vous pouvez consulter la \n[vignette](https://cran.r-project.org/web/packages/validate/vignettes/cookbook.html) du package `validate`.\n\n**Remarque:** La prochaine fois que vous recevrez des données de vos collaborateurs, n'oubliez pas de leur demander le fichier de schéma associé (par exemple, au format YAML). Bonne chance !\n\n## 2.  Consultez les statistiques récapitulatives\n### Statistiques agrégées par lieu de collecte (pour toutes les dates)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics \n\ndata_use%>%\n   dplyr::group_by(location)%>%\n     dplyr::summarise(nobs=n(),\n                      mean_prev=mean(prev_updated),\n                      min_prev=min(prev_updated),\n                      max_prev=max(prev_updated))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  location    nobs mean_prev min_prev max_prev\n  <chr>      <int>     <dbl>    <dbl>    <dbl>\n1 mordor       105     0.314   0.158     0.488\n2 narnia       104     0.326   0.08      0.488\n3 neverwhere    95     0.301   0         0.486\n4 oz           104     0.255   0.0714    0.459\n5 wonderland   105     0.382   0.194     0.535\n```\n\n\n:::\n:::\n\n\n\n### Statistiques agrégées par lieu de collecte et par année \n\nLe tableau s'allonge. Il pourrait être trop compliqué d'ajouter des contrôles par mois et par groupe d'âge.\n\nRemarque: Pourquoi n'y a-t-il que 3 mesures en 2020?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics by location\ndata_use%>%\n  dplyr::group_by(location, year)%>%\n  dplyr::summarise(nobs=n(),\n                   mean_prev=mean(prev_updated),\n                   min_prev=min(prev_updated),\n                   max_prev=max(prev_updated))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 6\n# Groups:   location [5]\n   location    year  nobs mean_prev min_prev max_prev\n   <chr>      <dbl> <int>     <dbl>    <dbl>    <dbl>\n 1 mordor      2018    36     0.318   0.206     0.473\n 2 mordor      2019    36     0.313   0.170     0.451\n 3 mordor      2020    33     0.312   0.158     0.488\n 4 narnia      2018    36     0.340   0.138     0.449\n 5 narnia      2019    36     0.361   0.216     0.488\n 6 narnia      2020    32     0.270   0.08      0.483\n 7 neverwhere  2018    36     0.304   0         0.45 \n 8 neverwhere  2019    56     0.298   0.0370    0.486\n 9 neverwhere  2020     3     0.307   0.04      0.473\n10 oz          2018    35     0.252   0.0714    0.459\n11 oz          2019    36     0.254   0.0861    0.446\n12 oz          2020    33     0.260   0.112     0.405\n13 wonderland  2018    36     0.365   0.255     0.454\n14 wonderland  2019    36     0.388   0.194     0.535\n15 wonderland  2020    33     0.393   0.276     0.476\n```\n\n\n:::\n:::\n\n\n\n::: {#challenge1 .callout-tip}\n## Défi 1 : Explorer les ensembles de données `data_prev` et `data_use`\n* Créez un tableau indiquant le nombre d'entrées de données par groupe d'âge et par lieu de collecte pour chacun d'eux!\n* Dans quel groupe d'âge et dans quel localité les observations ont-elles été supprimées?\n:::\n\n\nUn peu plus avancé. Utilisation de listes (ce n'est pas le sujet du cours mais c'est un point important).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics by location\ndata_use_list <- data_use%>%\n                  dplyr::group_split(location)\n```\n:::\n\n\n\nOu utilisez la librairie `purrr` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics by location, map summary function\nlibrary(purrr)\n\ndata_use_age_summary <- purrr::map(.x=seq(length(data_use_list)),\n                                   .f=function(x){\n                                     data_use_list[[x]]%>%\n                                       dplyr::group_by(location,year,ages)%>%\n                                       dplyr::summarise(nobs=n(),\n                                                        mean_prev=mean(prev_updated),\n                                                        min_prev=min(prev_updated),\n                                                        max_prev=max(prev_updated)) \n                                     \n                                   })\n```\n:::\n\n\n\n### Concentrons-nous maintenant sur le premier objet de la liste (mordor)\nNous savons que les femmes enceintes et les enfants de moins de 5 ans sont les plus vulnérables.\n\nOutput (ages) n'est pas ordonné comme nous le souhaiterions (chronologiquement).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics by location\n\ndata_mordor <- data_use_age_summary[[1]]\n\ndata_mordor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 7\n# Groups:   location, year [3]\n  location  year ages      nobs mean_prev min_prev max_prev\n  <chr>    <dbl> <chr>    <int>     <dbl>    <dbl>    <dbl>\n1 mordor    2018 15_above    12     0.270    0.206    0.369\n2 mordor    2018 5_to_14     12     0.335    0.219    0.427\n3 mordor    2018 under_5     12     0.348    0.259    0.473\n4 mordor    2019 15_above    12     0.266    0.170    0.377\n5 mordor    2019 5_to_14     12     0.278    0.176    0.390\n6 mordor    2019 under_5     12     0.394    0.315    0.451\n7 mordor    2020 15_above    11     0.255    0.158    0.333\n8 mordor    2020 5_to_14     11     0.352    0.258    0.488\n9 mordor    2020 under_5     11     0.330    0.190    0.422\n```\n\n\n:::\n:::\n\n\n\n### Comment procéder ?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics with age groups\nage_order <- c(\"under_5\",\"5_to_14\",\"15_above\")\n\ndata_use_ordered <- data_use\n\ndata_use_ordered$age_group <- factor(data_use$ages, levels =age_order)\n\ndata_mordor_reordered <- data_use_ordered%>%\n                           dplyr::group_by(location, year,age_group)%>%\n                            dplyr::summarise(nobs=n(),\n                                             mean_prev=mean(prev_updated),\n                                             min_prev=min(prev_updated),\n                                             max_prev=max(prev_updated))%>%\n                                 dplyr::filter(location==\"mordor\")\n```\n:::\n\n\n\nComparons les deux\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare for Mordor\n\ndata_mordor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 7\n# Groups:   location, year [3]\n  location  year ages      nobs mean_prev min_prev max_prev\n  <chr>    <dbl> <chr>    <int>     <dbl>    <dbl>    <dbl>\n1 mordor    2018 15_above    12     0.270    0.206    0.369\n2 mordor    2018 5_to_14     12     0.335    0.219    0.427\n3 mordor    2018 under_5     12     0.348    0.259    0.473\n4 mordor    2019 15_above    12     0.266    0.170    0.377\n5 mordor    2019 5_to_14     12     0.278    0.176    0.390\n6 mordor    2019 under_5     12     0.394    0.315    0.451\n7 mordor    2020 15_above    11     0.255    0.158    0.333\n8 mordor    2020 5_to_14     11     0.352    0.258    0.488\n9 mordor    2020 under_5     11     0.330    0.190    0.422\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_mordor_reordered\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 7\n# Groups:   location, year [3]\n  location  year age_group  nobs mean_prev min_prev max_prev\n  <chr>    <dbl> <fct>     <int>     <dbl>    <dbl>    <dbl>\n1 mordor    2018 under_5      12     0.348    0.259    0.473\n2 mordor    2018 5_to_14      12     0.335    0.219    0.427\n3 mordor    2018 15_above     12     0.270    0.206    0.369\n4 mordor    2019 under_5      12     0.394    0.315    0.451\n5 mordor    2019 5_to_14      12     0.278    0.176    0.390\n6 mordor    2019 15_above     12     0.266    0.170    0.377\n7 mordor    2020 under_5      11     0.330    0.190    0.422\n8 mordor    2020 5_to_14      11     0.352    0.258    0.488\n9 mordor    2020 15_above     11     0.255    0.158    0.333\n```\n\n\n:::\n:::\n\n\n\n\n\n## 3.  Utilisation des graphiques\n### Nous devons évaluer l’évolution de la prévalence pour toutes les régions par mois\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Plotting evolution over time\nevolution_plot <- ggplot2::ggplot(data=data_use_ordered,\n                                  mapping=aes(x=month,\n                                              y=prev_updated,\n                                              group=location,\n                                              colour=location))+\n                        ggplot2::geom_line(lwd=1.1)+\n                           ggplot2::facet_wrap(~year)+ \n                            ggplot2::theme_bw()+\n                             ggplot2::xlab(\"Month of the Year\")+\n                               ggplot2::ylab(\"Prevalence\")+\n                                ggplot2::scale_x_discrete(limits=factor(1:12),\n                                                          labels=c(\"J\",\"F\",\"M\",\n                                                                   \"A\",\"M\",\"J\",\n                                                                   \"J\",\"A\",\"S\",\n                                                                   \"O\",\"N\",\"D\"))+\n                                   ggplot2::scale_y_continuous(breaks=seq(from=0,\n                                                                          to=0.7,\n                                                                          by=0.1))\n\nevolution_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-evoplot-1.png){width=672}\n:::\n:::\n\n\n\n**Observation:** Graphique de prévalence avec des lignes verticales par mois et par an: nous avons plusieurs sous-groupes pour les données de prévalence et nous traçons des facettes pour les différentes catégories de `age_group`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Plotting evolution over time, fix 1\nevolution_plot_ages <- ggplot2::ggplot(data=data_use_ordered,\n                                  mapping=aes(x=month,\n                                              y=prev_updated,\n                                              group=location,\n                                              colour=location))+\n  ggplot2::geom_line(lwd=1.1)+\n  ggplot2::facet_wrap(age_group~year)+ \n  ggplot2::theme_bw()+\n  ggplot2::xlab(\"Month of the Year\")+\n  ggplot2::ylab(\"Prevalence\")+\n  ggplot2::scale_x_discrete(limits=factor(1:12),\n                            labels=c(\"J\",\"F\",\"M\",\n                                     \"A\",\"M\",\"J\",\n                                     \"J\",\"A\",\"S\",\n                                     \"O\",\"N\",\"D\"))+\n  ggplot2::scale_y_continuous(breaks=seq(from=0,\n                                         to=0.7,\n                                         by=0.1))\n\nevolution_plot_ages\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-evoplot-fix1-1.png){width=672}\n:::\n:::\n\n\n\n**Observation** :\nQIl y a quelques améliorations, mais nous avons toujours des lignes verticales, peut-être avons-nous d'autres variables de groupe. Regardons uniquement les lignes qui ont plus d'une entrée par emplacement, mois, année, groupe d'âge.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Plotting evolution over time, fix 2\n\ndata_use_ordered%>%\n  group_by(location,month,year,age_group)%>%\n  tally()%>%\n  filter(n>1)%>%\n  left_join(data_use_ordered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 48 × 13\n# Groups:   location, month, year [8]\n   location   month  year age_group     n ages     total positive xcoord ycoord\n   <chr>      <dbl> <dbl> <fct>     <int> <chr>    <dbl>    <dbl>  <dbl>  <dbl>\n 1 neverwhere     6  2019 under_5       2 under_5     24        4  -20.6   30.7\n 2 neverwhere     6  2019 under_5       2 under_5     26        1  -20.5   30.7\n 3 neverwhere     6  2019 5_to_14       2 5_to_14     27        5  -19.7   30.0\n 4 neverwhere     6  2019 5_to_14       2 5_to_14     27        8  -19.3   30.2\n 5 neverwhere     6  2019 15_above      2 15_above    70       31  -19.4   29.4\n 6 neverwhere     6  2019 15_above      2 15_above    74       27  -19.2   29.2\n 7 neverwhere     7  2019 under_5       2 under_5     25        5  -20.0   29.1\n 8 neverwhere     7  2019 under_5       2 under_5     26        4  -20.7   28.6\n 9 neverwhere     7  2019 5_to_14       2 5_to_14     27        7  -18.8   29.3\n10 neverwhere     7  2019 5_to_14       2 5_to_14     23        6  -20.4   29.8\n# ℹ 38 more rows\n# ℹ 3 more variables: prev <dbl>, time_order_loc <dbl>, prev_updated <dbl>\n```\n\n\n:::\n:::\n\n\n\n**Observation:**\nOK, nous voyons qu'au sein d'une même localité, il existe plusieurs points de données de prévalence même si les coordonnées `xcoord` et `ycoord` diffèrent. Afin d'avoir un seul graphique par lieu, nous pourrions faire la moyenne de `xcoord` et `ycoord` dans chaque localité. Il peut aussi s'agir d'enregistrements dupliqués, puisque `xcoord` et `ycoord` sont très proches?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Plotting evolution over time, fix 3\n\ndata_use_ordered%>%\n  group_by(location,month,year,age_group)%>%\n  summarize(prev_updated_mean=mean(prev_updated),\n            prev_updated_min=min(prev_updated),\n            prev_updated_max=max(prev_updated))%>%\n  ggplot2::ggplot(mapping=aes(x=month,\n                              y=prev_updated_mean,\n                              file=location,\n                              group=location,\n                              colour=location))+\n  ggplot2::geom_line(lwd=1.1)+\n  ggplot2::facet_wrap(age_group~year)+ \n  ggplot2::theme_bw()+\n  ggplot2::xlab(\"Month of the Year\")+\n  ggplot2::ylab(\"Prevalence\")+\n  ggplot2::scale_x_discrete(limits=factor(1:12),\n                            labels=c(\"J\",\"F\",\"M\",\n                                     \"A\",\"M\",\"J\",\n                                     \"J\",\"A\",\"S\",\n                                     \"O\",\"N\",\"D\"))+\n  ggplot2::scale_y_continuous(breaks=seq(from=0,\n                                         to=0.7,\n                                         by=0.1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-evoplot-fix3-1.png){width=672}\n:::\n:::\n\n\n**Observation:** \nLa prévalence est très variable tout au long de l'année selon les endroits en moyenne; Wonderland étant affecté par une prévalence élevée tandis qu'Oz a la prévalence la plus faible.\n\n\n# Il faut vérifier (pas seulement la prévalence) mais aussi le nombre de cas et le nombre total de personnes vulnérables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Check case count\n\ndata_use_ordered_long <- tidyr::pivot_longer(data=data_use_ordered,\n                                             cols=c(\"positive\",\"total\"),\n                                             names_to=\"Outcome\",\n                                             values_to=\"counts\")\n\n\nmordor_stacked_bar_graph <- ggplot2::ggplot(data=data_use_ordered_long%>%\n                                                       dplyr::filter(location==\"mordor\"),\n                                                 mapping=aes(x=month,\n                                                             y=counts,\n                                                             fill=Outcome))+\n                                       ggplot2::scale_x_discrete(limits=factor(1:12),\n                                                                 labels=c(\"J\",\"F\",\"M\",\n                                                                          \"A\",\"M\",\"J\",\n                                                                          \"J\",\"A\",\"S\",\n                                                                          \"O\",\"N\",\"D\"))+\n                                           ggplot2::geom_bar(position=\"stack\", stat=\"identity\")+\n                                             ggplot2::facet_wrap(~year)+ \n                                               ggplot2::theme_bw()+\n                                                 ggplot2::xlab(\"Month of the Year\")+\n                                                    ggplot2::ylab(\"Count\")\n\nmordor_stacked_bar_graph\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-casecount-1.png){width=672}\n:::\n:::\n\n\n\n**Observation:** \nLe graphique à barres empilées additionne les nombres de `positifs` et les totaux. Il est préférable de les afficher côte à côte car les nombres de positifs sont un sous-ensemble des nombres totaux. Ceci est spécifié par l'argument `position=\"dodge\"` dans la géométrie `geom_bar` de `ggplot2`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Case count, bargraph dodge\n\nmordor_dodged_bar_graph <- ggplot2::ggplot(data=data_use_ordered_long%>%\n                                              dplyr::filter(location==\"mordor\"),\n                                            mapping=aes(x=month,\n                                                        y=counts,\n                                                        fill=Outcome))+\n  ggplot2::scale_x_discrete(limits=factor(1:12),\n                            labels=c(\"J\",\"F\",\"M\",\n                                     \"A\",\"M\",\"J\",\n                                     \"J\",\"A\",\"S\",\n                                     \"O\",\"N\",\"D\"))+\n  ggplot2::geom_bar(position=\"dodge\", stat=\"identity\")+\n  ggplot2::facet_wrap(~year)+ \n  ggplot2::theme_bw()+\n  ggplot2::xlab(\"Month of the Year\")+\n  ggplot2::ylab(\"Count\")\n\nmordor_dodged_bar_graph\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-casecount-dodgedbar-1.png){width=672}\n:::\n:::\n\n\n\n## L'ensemble de données sur les moustiques\n\nJetons un oeil à l'ensemble de données `mosq_data`.\n\nNous vérifions la cohérence de cet ensemble de données en affichant un tableau des valeurs enregistrées par colonne:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data %>%\n  map( function(x) table(x) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$session\nx\n 1  2 \n52 52 \n\n$Village\nx\nnaernia  narnia \n      2     102 \n\n$Compound.ID\nx\n 1  2  3  4 \n26 26 26 26 \n\n$Method\nx\nALC HLC \n  1 103 \n\n$Location\nx\n Indoor Outdoor \n     52      52 \n\n$hour\nx\n01h-02h 02h-03h 03h-04h 04h-05h 05h-06h 06h-07h 07h-08h 19h-20h 20h-21h 21h-22h \n      8       8       8       8       8       8       8       8       8       8 \n22h-23h 23h-24h 24h-01h \n      8       8       8 \n\n$ag.Male\nx\n 0  3  4  5  6  7 14 16 20 22 27 35 \n93  1  1  1  1  1  1  1  1  1  1  1 \n\n$Ag.unfed\nx\n 0  1  2  3  4  5  6  7  8 10 20 \n57 13  7  8  4  4  2  4  2  1  2 \n\n$Ag.halffed\nx\n 0  3  4  5  8  9 \n92  3  3  3  1  2 \n\n$Ag.fed\nx\n 0  1  3  5 \n88  7  3  6 \n\n$Ag.grsgr\nx\n 0  1  2  3  4  6  8 12 17 20 23 27 35 37 \n70 13  6  1  2  1  3  2  1  1  1  1  1  1 \n\n$tot.gamb\nx\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 23 \n40 10 10  9  8  6  3  2  1  1  5  2  1  2  2  2 \n\n$Culex.male\nx\n  0 \n104 \n\n$Culex.female\nx\n 0  1  2 \n94  9  1 \n\n$Mansonia.male\nx\n  0   1 \n103   1 \n\n$Mansonia.female\nx\n 0  1  2 \n90 11  3 \n\n$Aedes.male\nx\n  0 \n104 \n\n$Aedes.female\nx\n 0  1  2 \n98  5  1 \n```\n\n\n:::\n:::\n\n\n\nIl semblerait que nous ayons quelques fautes de frappe dans les noms de `Method` and `Village`.\n\n::: {#challenge2 .callout-tip}\n## Défi 2 : Utilisation de schémas pour l'ensemble de données sur les moustiques\n\n* Créez un *schéma* qui fournit des règles pour les strings  (c'est-à-dire les chaînes de caractères) attendues dans les colonnes `Method` et `Village`.\n* Utiliser la syntaxe fournie [ici](#data-validation-schema)\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschema <- validate::validator(Method%in%c(\"HLC\"),\n                              Village%in%c(\"narnia\"))\n\nout   <- validate::confront(mosq_data, schema)\nsummary(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  name items passes fails nNA error warning                expression\n1   V1   104    103     1   0 FALSE   FALSE     Method %vin% c(\"HLC\")\n2   V2   104    102     2   0 FALSE   FALSE Village %vin% c(\"narnia\")\n```\n\n\n:::\n:::\n\n\n\n\nLes colonnes `Village` et `Method` semblent avoir des erreurs de saisie de données. Nous devons corriger cela.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data<-mosq_data%>%\n  mutate(Method=ifelse(Method==\"ALC\",\"HLC\",Method),\n         Village=ifelse(Village==\"naernia\",\"narnia\",Village))\n```\n:::\n\n\n\n\nIl semble que les différentes colonnes concernent les tailles de population d'*Anopheles Gambiae*. Modifions les noms des colonnes en utilisant `rename` du package `tidyverse`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data%>%\n  rename(\"AnophelesGambiae.male\"=\"ag.Male\",\n         \"AnophelesGambiae.unfed\"=\"Ag.unfed\",\n         \"AnophelesGambiae.halffed\"=\"Ag.halffed\",\n         \"AnophelesGambiae.fed\"=\"Ag.fed\",\n         \"AnophelesGambiae.gravid\"=\"Ag.grsgr\")->mosq_data\n```\n:::\n\n\n\n\nIl semble que `tot.gamb` devrait compter le nombre total d'Anopheles\nGambiae. Vérifions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data%>%\n  mutate(AnophelesGambiae_total=AnophelesGambiae.male+AnophelesGambiae.unfed+AnophelesGambiae.halffed+AnophelesGambiae.fed+AnophelesGambiae.gravid)->mosq_data\n\nmosq_data%>%\n  filter(AnophelesGambiae_total!=tot.gamb)%>%select(AnophelesGambiae_total,tot.gamb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 2\n   AnophelesGambiae_total tot.gamb\n                    <dbl>    <dbl>\n 1                     12        0\n 2                     16        2\n 3                      0        6\n 4                     24        8\n 5                     24        1\n 6                     74       12\n 7                     54        3\n 8                     70        1\n 9                     34        2\n10                     40        2\n11                     46        0\n```\n\n\n:::\n:::\n\n\n\nDonc 11 lignes sur 104 présentent cette divergence. Gardons plutôt `Anopheles.total`, puisqu'il a été calculé à partir des données.\n\nComme le statut des Anopheles est mutuellement exclusif dans les données HLC, nous pouvons dessiner un graphique à barres empilées, avec la couleur des barres définie par le statut. Pour produire un tel graphique efficacement dans `ggplot2`, nous devons faire pivoter le tableau.\n\nIci en particulier, nous voulons passer d'un format large à un format long afin d'obtenir une colonne décrivant le statut des moustiques Anopheles. Nous utiliserons notamment l'argument `names_sep` de la fonction `pivot_longer` pour séparer par exemple le nom de colonne `AnophelesGambiae.male` et utiliser `male` comme niveau dans une nouvelle colonne appelée `status`. Il en va de même pour les autres noms de colonnes.\n\nIntégrer les variables `session`, `Village`, `Compound.ID`, `Method`, `Location`, `hour`, `AnophelesGambiae_total` dans la définition de la variable de regroupement aidera à conserver ces variables dans le tableau au format long.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data%>%\n  group_by(session,Village,Compound.ID,Method,Location,hour,AnophelesGambiae_total)%>%\n  select(contains(\"AnophelesGambiae.\"))%>%\n  pivot_longer(cols=contains(\"AnophelesGambiae.\"),names_sep=\"AnophelesGambiae.\",names_to=c(NA,\"status\"),values_to = \"AnophelesGambiae\")->mosq_data_gamb_wide\n\nmosq_data_gamb_wide%>%\n  ggplot()+\n  geom_bar(aes(x=hour,y=AnophelesGambiae,fill=status),position=\"stack\",stat=\"identity\")+\n  scale_x_discrete(guide = guide_axis(angle = 60))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-mosqdata-pivot-1.png){width=672}\n:::\n:::\n\n\n\n**Observation**: Nous avons plusieurs valeurs pour `Compound.ID`. La géométrie `geom_bar` les additionne automatiquement dans le graphique. Nous pouvons utiliser `facet_wrap` pour voir ces strates:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data_gamb_wide%>%\n  ggplot()+\n  geom_bar(aes(x=hour,y=AnophelesGambiae,fill=status),position=\"stack\",stat=\"identity\")+\n  scale_x_discrete(guide = guide_axis(angle = 60))+\n  facet_wrap(~Compound.ID)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-mosqdata-pivot-line-1.png){width=672}\n:::\n:::\n\n\n\nNous pouvons aussi utiliser notre variable `Anopheles_total` et la représenter comme un grapique ligne au dessus du grapique en barres:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosq_data_gamb_wide%>%\n  mutate(grouping=paste0(Compound.ID,Location,session))%>%\n  ggplot()+\n  geom_bar(aes(x=hour,y=AnophelesGambiae,fill=status),position=\"stack\",stat=\"identity\")+\n  geom_line(aes(x=hour,y=AnophelesGambiae_total,group=grouping))+\n  scale_x_discrete(guide = guide_axis(angle = 60))+\n  facet_wrap(~Compound.ID+session+Location)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-mosqdata-pivot-disagg-1.png){width=672}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}